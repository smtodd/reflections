What happens when you initialize a repository? Why do you need to do it?
	Initializing a repository adds a .git folder to the folder (directory) you are in.
	If you want to start a new git repository, it's what you do.
How is the staging area different from the working directory and the repository? What value do you think it offers?
	The staging area is a temporary holding area for items that are going into the git repository.  It offers the option to select only some of the files to go into the repository.  It also offers a final chance to double check which files you want to put in.
Why did my commits not work for a while?
	I had somehow changed the local core.editor in this repository to --help. It must be from one of the mistakes I made when I was playing around figuring out how to set and use the core.editor.  I was trying to see if I could make some changes so that only one sublime file would open when I used git commit.  One of the things I tried must have messed up the local core.editor
What are some situations when branches would be helpful in keeping your history organized.  How would branches help.
	Branches could be used if you had different devs working on different features of a project at the same time.  Each dev could have a branch with their name. It could also be helpful if you were adding multiple features at once.  Or if you had a branch to work on a new feature and a master branch that clients were using where updates would only be bug fixes.
How do the diagrams help you visualize the branch structure?
	I don't think I would have a clue what this was talking about without the diagrams. I tend to see the world as images in my head that can be described by words.  Without the pics, I wouldn't know what a branch was.
What is the result of merging two branches together? Why do we represent it in the diagram the way we do?
	Merging the files initially produced and error because I had changed the bullet delay statement several times and the merge got confused. But I learned how to open up the files, find the different lines,and make a commit to get them resolved.  The final product of this merge was a game that had the updates like color that were on the main branch and the coins feature. Merge selects new and altered lines from each branch as compared to the original.  If the same line is altered in two different ways, merge gets confused and must be cleared up manually. Also, if complete files are added or deleted, a manual commit must be made since merge cannot handle it automatically.
What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?
	Automatic merging is faster than manual merging, and it prevents you from overlooking an important change.  But it could make incorrect calls, what if a line was changed from the original but what you actually wanted was the original?  If two different people are working on it, maybe after talking, you would have decided you liked the original.